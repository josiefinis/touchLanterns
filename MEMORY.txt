# MEMORY BRANCH - Manage memory better.

    It is likely that a memory issue has caused the program to hang. Specifically heap fragmentation caused by dynamic memory allocation of the PWM queue.
    Have changed the queue implementation in PWM to an array, which now takes up a bunch of space as a global variable on the stack.
    This is presumably better than it being on the heap but can maybe do better.
    Should also look at memory use by the rest of the program.

## Actions
    * Learn more about Arduino memory, continue reading here https://docs.arduino.cc/learn/programming/memory-guide 
    * Avoid dynamic memory allocation.
      - Look into changing queue and linked list implementation.
        * queue in makeTree
         - not used outside of makeTree, can this be done roughly as is but on the stack?
        * neighbour list
          - change to array
          - is constant, but want to shuffle and have quick access on occasion makeTree is called
          - can maybe put in program memory and copy to RAM in advance when needed.
        * [DONE] brightness queue
          - a lot of memory, 256 bytes
          - more than PWM, likely causing problems
          - change to procedural, is anyway generated by simple functions

    * Reduce memory used by global variables on stack.
      - neighbour list, see above.
      - clean up old code
      - streamline Lantern class maybe
      - SerialMonitor class uses a lot of memory, even when not included. 
        * Figure out how to stop it taking up memory when not used. 
          - presumably move out of working directory
          - maybe make it into a library? how does that work?


brightness queue
instead of queue, generate as needed

raiseBrightness( rate, ceiling )
lowerBrightness( rate, ceiling )

nextBrightness()
  brightness += 

getBrightness()
  return brightness;


Can't just increment for next brightness since step size can be less than one. 
Could just change brightness to uint16_t and scale up so that step size is always greater than one. Requires 16 more bytes.
Could have a single counter for all lanterns and calculate brightness at each step using same formula as now. i.e.

static uint8_t k;

getBrightness() {
  return brightness + k * rate / 16;

but need to think about how to share a common counter, when k should be zero for each lantern.
could syncronise k=0 for all lanterns although this would cause discontinuity when rate of brightness change is changed.

so instead
getBrightness() {
  return brightness + f(k) * rate / 16;

but this is complicated by the fact that lanterns are updated in gray code order.

questionable that it is worth the added code complexity to save 15 bytes.

Try out increasing brightness resolution from 8-bit to 12-bit and see how it goes.

Also need to store rate and ceiling.
Can probably use targetBrightness for ceiling but keep as uint8_t and handle scale conversion.
Could store rate in unused bits of brightness (if enough).
Greatest change currently 32 (excluding full up and down which can easily be recoded as setBrightness)
Would need to rescale by 16 so are short by 1 bit. However are currently using only rates that are powers of 2 so can store the exponent.
Implementation is probably actually not so complex, e.g.

nextBrightness() {
  brightness += 1 << ( brightness >> 12 )
}

also need to store if it is a positive or negative brightness change
also need to store special cases flicker and pulse, and potentially more.
positive/negative change is stored in the state, as is flicker.
would need check state machine for transitions that contain output and possibly remove some flicker ones.

should maybe probably just make things simpler and have a new 'output' variable that can manage rate, flicker, pulse and potentially other effects.
could perhaps change/incorporate 'delay' e.g. instead of 12-bit brightness where least significant 4-bits are rounded away could instead use 'delay' for those 4 bits and carry into brightness. or e.g. combine 'delay' and 'brightness' into one variable, which makes logical sense at least in the way 'delay' is currently used in IDLE to control very slow brightness transitions. Might not work so nicely with how 'delay' is used to control delay in WAIT. although, have an idea,


use most significant bit to encode if output is normal (brightness) or special (delay, flicker etc) output.

uint16_t output;

    F   E   D   C   B   A   9   8   7   6   5   4   3   2   1   0
  | 0 |<---rate-->|<----------brightness--------->|<--b. LSBs---->|
  | 1 |<---type-->|<-------------counter/other------------------->|

Relies on not having to perform normal and special output at the same time. A lantern can have brightness while in WAIT and currently uses 'delay' while in IDLE. Was thinking this could be circumvented but now not sure. In fact pretty sure it can't without storing data somewhere. Still have brightness target though, so it can work. (or target brightness, whatever it's called it needs a different name). Nope, brightness target exists especially for IDLE behaviour. So need to think again.



Currently have
  uint8_t delay
  uint8_t brightness
  uint8_t brightness target

  A sticking point is the range of different rates of brightness change, currently 1 to 256, over 16 periods (also have 1/256 changes during IDLE). 
  Over 1 period that is 1/16 to 16

  Ok, perhaps a sensible plan is to have

  uint16_t brightness               [4 unused][ 12 bit brightness 0-4095]
  uint8_t brightnessTarget          [ 8 bit brightness ]
  uint16_t output                   handle rate and counters

  then if feasible the extra 4 bits brightness resolution could be put in output maybe.

  Or wait surely

  uint16_t output                   [1 bit][3 bits rate][ 12 bit brightness ] (as above)
  uint8_t target brightness
  uint8_t delay

  which is one byte less and makes more sense naming wise. Also fewer changes.


  
### Change neighbour list.

Look at timeline for when neighbour list is needed in RAM

start               set neighbours, shuffle
makeTree            get neighbour
leaves ROOT         shuffle, reset index
leaves WAIT         shuffle, reset index

Might not be worthwhile to use PROGMEM for neighbours. Shelve idea for now.

Queue implementaton using array.
Max length of queue:

    in queue    remaining
    1           15
    4           10
    6           7
    8           4
    10          1

    



